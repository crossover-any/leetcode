# 数据结构



## LeetCode

### 每日一题

#### 2021-4-21 [解码方法 ](https://leetcode-cn.com/problems/decode-ways/)

##### 题目

```
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> 1

'B' -> 2

...

'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
```



##### 示例

```
示例 1：

输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2：

输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
示例 3：

输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
示例 4：

输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
```



##### 提示

```
1 <= s.length <= 100
s 只包含数字，并且可能包含前导零。
```



##### 解题思路

###### 解题思路1-动态规划

首先，我们以"11106"字符串为例看一下思路，从左往右遍历

第一次遍历: 当前数字等于1，只有一种情况 即 A

第二次遍历：当前数字等于1，可以选择与前面的1组合成11(K)，也可单独组成 1(A)

第三次遍历：当前数字等于1，同样也可以选择与前面的1组合成11（K）,也可单独组成1（A）

第四次遍历：当前数字等于0，不能单独编码，因为没有与0对应的编码，只能选择与前面的1组合，10（J）

第五次遍历：当前数字等于6，可以单独编码（F），但是不能与前面组合成06.

通过上面的遍历我们有了大致的一个思路，广义化题目。假设给我们一个长度为n的字符串，我们可将其视为一个从长度1开始慢慢增加到n的一个过程。换一种方式来说，如果已知一个长度为n的字符串编码方式有 m种，请问如果在其后面再加一个字符，那么此时长度为n+1 的字符串的编码方式有多少种。

建立一个方程 有 y= f(x),自变量x是当字符串长度为时，当前有多少中编码方式，那么我们思考怎么求解这个方程(考虑一般情况下)

易知: 

f(1) = 1

f(2) = 2

f(3) = 3

f(4) = 2

f(x) = ?

我们知道 x 位置只能有两张组合方式，要不单独编码，要不与前面的数字组合。所以在x的编码组合方式就等于 = 单独编码方式数量 + 组合编码方式数量，**如果选择单独编码那么数量将等于x-1时的编码总数，如果选择组合编码方式那么数量等于x-2时的编码总数。** 当然，这里不是每个x都会有这两种组合方式，如果当前数字是0 那么只有选择与前面的数字组合编码，并且组合后的编码合法（小于等于26）。如果前一个数字是0那么只能选择单独编码（例如 06不等于6,）。

那么f(x)的值与f(x-1)与f(x-2)有关。

如果x位置的数字不等于0，x-1位置的数字不等于0，并且与上一个数字组合的数字<=26,那么 f(x) = f(x-1) + f(x-2)

如果x位置的数字不等于0，x-1位置的数字等于0,那么f(x) = f(x-1)

如果x位置的数字等于0，x-1位置的数字不等于0，并且与上一个数字组合的数字<=26，那么f(x) = f(x-2)

如果x位置的数字等于0，x-1位置的数字等于0，返回0（非法）

```Java
    private final String STR_ZERO = "0";
    public int numDecodings1(String s) {
        if (s != null && s.length() > 0) {
            int preNum = 0;
            int prePreNum = 0;
            //初始化操作,边界条件，因为遍历时需要知道上一个编码数量和上上一个编码数量
            if (Integer.parseInt(s.substring(0, 1)) != 0) {
                preNum = 1;
                if (s.length() > 1 && Integer.parseInt(s.substring(0,2)) <= 26){
                    prePreNum = 1;
                }
            } else {
                return 0;
            }
            for (int i = 1; i < s.length(); i++) {
                String curStr = s.substring(i, i + 1);//当前数字
                String preStr = s.substring(i - 1, i);//上一个数字
                int num = 0;
                //如果当前数字等于0
                if (curStr.equals(STR_ZERO)) {
                    //如果前一个数字等于0
                    if (preStr.equals(STR_ZERO)) {
                        return 0;
                    } else {
                        num = Integer.parseInt(preStr + curStr);
                        if (num > 26) {
                            return 0;
                        } else {
                            //如果当前数字等于0，前一个数字不等于0，组合合法，编码数量等于前一个数字的数量
                            int temp = preNum;
                            preNum = prePreNum;
                            prePreNum = temp;
                        }
                    }
                } else {
                    if (preStr.equals(STR_ZERO)) {
                        //如果当前数字不等于0，前一个数字等于0，当前编码数量等于前一个数字的数量
                        prePreNum = preNum;
                    } else {
                        num = Integer.parseInt(preStr + curStr);
                        if (num <= 26) {
                            int temp = preNum;
                            preNum = prePreNum + preNum;
                            prePreNum = temp;
                        } else {
                            prePreNum = preNum;
                        }
                    }
                }
            }
            return preNum;
        }
        return 0;
    }
```

优化代码



```Java
    public int numDecodings(String s) {
         int n = s.length();
        // a = f[i-2], b = f[i-1], c=f[i]
        int a = 0, b = 1, c = 0;
        for (int i = 1; i <= n; ++i) {
            c = 0;
            if (s.charAt(i - 1) != '0') {
                c += b;
            }
            if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26)) {
                c += a;
            }
            a = b;
            b = c;
        }
        return c;
    }
}
```







